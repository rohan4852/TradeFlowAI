import { WebSocketManager, WS_STATES, MESSAGE_TYPES } from '../websocketManager'; \n\n// Mock WebSocket\nclass MockWebSocket {\n  constructor(url, protocols) {\n    this.url = url;\n    this.protocols = protocols;\n    this.readyState = WebSocket.CONNECTING;\n    this.onopen = null;\n    this.onclose = null;\n    this.onmessage = null;\n    this.onerror = null;\n    \n    // Simulate connection after a short delay\n    setTimeout(() => {\n      this.readyState = WebSocket.OPEN;\n      if (this.onopen) {\n        this.onopen({ type: 'open' });\n      }\n    }, 10);\n  }\n  \n  send(data) {\n    this.lastSentMessage = data;\n  }\n  \n  close(code, reason) {\n    this.readyState = WebSocket.CLOSED;\n    if (this.onclose) {\n      this.onclose({ code, reason, type: 'close' });\n    }\n  }\n  \n  // Helper method to simulate receiving messages\n  simulateMessage(data) {\n    if (this.onmessage) {\n      this.onmessage({ data: JSON.stringify(data), type: 'message' });\n    }\n  }\n  \n  // Helper method to simulate errors\n  simulateError(error) {\n    if (this.onerror) {\n      this.onerror({ error, type: 'error' });\n    }\n  }\n}\n\n// Mock global WebSocket\nglobal.WebSocket = MockWebSocket;\nWebSocket.CONNECTING = 0;\nWebSocket.OPEN = 1;\nWebSocket.CLOSING = 2;\nWebSocket.CLOSED = 3;\n\ndescribe('WebSocketManager', () => {\n  let wsManager;\n  \n  beforeEach(() => {\n    wsManager = new WebSocketManager({\n      url: 'wss://test.example.com/ws',\n      debug: false,\n      reconnectInterval: 100,\n      maxReconnectAttempts: 3,\n      heartbeatInterval: 1000\n    });\n  });\n  \n  afterEach(() => {\n    if (wsManager) {\n      wsManager.destroy();\n    }\n  });\n  \n  describe('Connection Management', () => {\n    test('should initialize with disconnected state', () => {\n      expect(wsManager.getState()).toBe(WS_STATES.DISCONNECTED);\n      expect(wsManager.isConnected()).toBe(false);\n    });\n    \n    test('should connect successfully', async () => {\n      const connectPromise = wsManager.connect();\n      \n      expect(wsManager.getState()).toBe(WS_STATES.CONNECTING);\n      \n      await connectPromise;\n      \n      expect(wsManager.getState()).toBe(WS_STATES.CONNECTED);\n      expect(wsManager.isConnected()).toBe(true);\n    });\n    \n    test('should disconnect cleanly', async () => {\n      await wsManager.connect();\n      \n      wsManager.disconnect();\n      \n      expect(wsManager.getState()).toBe(WS_STATES.DISCONNECTED);\n      expect(wsManager.isConnected()).toBe(false);\n    });\n    \n    test('should handle connection errors', async () => {\n      const errorHandler = jest.fn();\n      wsManager.on('error', errorHandler);\n      \n      // Override the WebSocket constructor to simulate immediate error\n      const originalWebSocket = global.WebSocket;\n      global.WebSocket = class extends MockWebSocket {\n        constructor(url, protocols) {\n          super(url, protocols);\n          setTimeout(() => {\n            this.simulateError(new Error('Connection failed'));\n          }, 5);\n        }\n      };\n      \n      try {\n        await wsManager.connect();\n      } catch (error) {\n        expect(error.message).toBe('WebSocket connection failed');\n      }\n      \n      expect(errorHandler).toHaveBeenCalled();\n      \n      // Restore original WebSocket\n      global.WebSocket = originalWebSocket;\n    });\n  });\n  \n  describe('Message Handling', () => {\n    beforeEach(async () => {\n      await wsManager.connect();\n    });\n    \n    test('should send messages when connected', () => {\n      const message = { type: 'test', data: 'hello' };\n      const result = wsManager.send(message);\n      \n      expect(result).toBe(true);\n      expect(wsManager.ws.lastSentMessage).toBe(JSON.stringify(message));\n    });\n    \n    test('should queue messages when disconnected', () => {\n      wsManager.disconnect();\n      \n      const message = { type: 'test', data: 'hello' };\n      const result = wsManager.send(message);\n      \n      expect(result).toBe(false);\n      expect(wsManager.messageQueue).toContain(message);\n    });\n    \n    test('should handle incoming messages', () => {\n      const messageHandler = jest.fn();\n      wsManager.on('message', messageHandler);\n      \n      const testMessage = { type: 'test', data: 'hello' };\n      wsManager.ws.simulateMessage(testMessage);\n      \n      expect(messageHandler).toHaveBeenCalledWith(testMessage);\n    });\n    \n    test('should handle price updates', () => {\n      const priceHandler = jest.fn();\n      wsManager.on('priceUpdate', priceHandler);\n      \n      const priceUpdate = {\n        type: MESSAGE_TYPES.PRICE_UPDATE,\n        symbol: 'BTC/USD',\n        price: { price: 50000, change: 100 }\n      };\n      \n      wsManager.ws.simulateMessage(priceUpdate);\n      \n      expect(priceHandler).toHaveBeenCalledWith(priceUpdate);\n    });\n    \n    test('should handle orderbook updates', () => {\n      const orderbookHandler = jest.fn();\n      wsManager.on('orderbookUpdate', orderbookHandler);\n      \n      const orderbookUpdate = {\n        type: MESSAGE_TYPES.ORDERBOOK_UPDATE,\n        symbol: 'BTC/USD',\n        orderbook: { asks: [], bids: [] }\n      };\n      \n      wsManager.ws.simulateMessage(orderbookUpdate);\n      \n      expect(orderbookHandler).toHaveBeenCalledWith(orderbookUpdate);\n    });\n    \n    test('should handle heartbeat messages', () => {\n      const heartbeat = {\n        type: MESSAGE_TYPES.HEARTBEAT,\n        timestamp: Date.now()\n      };\n      \n      wsManager.ws.simulateMessage(heartbeat);\n      \n      expect(wsManager.lastHeartbeat).toBeTruthy();\n      expect(wsManager.ws.lastSentMessage).toContain('\"type\":\"pong\"');\n    });\n  });\n  \n  describe('Subscription Management', () => {\n    beforeEach(async () => {\n      await wsManager.connect();\n    });\n    \n    test('should subscribe to channels', () => {\n      wsManager.subscribe('price.BTC/USD', { interval: '1s' });\n      \n      expect(wsManager.subscriptions.size).toBe(1);\n      expect(wsManager.ws.lastSentMessage).toContain('\"type\":\"subscribe\"');\n      expect(wsManager.ws.lastSentMessage).toContain('\"channel\":\"price.BTC/USD\"');\n    });\n    \n    test('should unsubscribe from channels', () => {\n      wsManager.subscribe('price.BTC/USD');\n      wsManager.unsubscribe('price.BTC/USD');\n      \n      expect(wsManager.subscriptions.size).toBe(0);\n      expect(wsManager.ws.lastSentMessage).toContain('\"type\":\"unsubscribe\"');\n    });\n    \n    test('should resubscribe after reconnection', async () => {\n      wsManager.subscribe('price.BTC/USD');\n      wsManager.subscribe('orderbook.ETH/USD');\n      \n      expect(wsManager.subscriptions.size).toBe(2);\n      \n      // Simulate disconnection and reconnection\n      wsManager.ws.close(1006, 'Connection lost');\n      \n      // Wait for reconnection\n      await new Promise(resolve => {\n        wsManager.on('connected', resolve);\n      });\n      \n      // Check that subscriptions were restored\n      expect(wsManager.subscriptions.size).toBe(2);\n    });\n  });\n  \n  describe('Reconnection Logic', () => {\n    test('should attempt reconnection on unexpected close', (done) => {\n      wsManager.connect().then(() => {\n        const reconnectingHandler = jest.fn();\n        wsManager.on('stateChange', ({ newState }) => {\n          if (newState === WS_STATES.RECONNECTING) {\n            reconnectingHandler();\n            expect(reconnectingHandler).toHaveBeenCalled();\n            done();\n          }\n        });\n        \n        // Simulate unexpected disconnection\n        wsManager.ws.close(1006, 'Connection lost');\n      });\n    });\n    \n    test('should not reconnect on intentional close', async () => {\n      await wsManager.connect();\n      \n      const reconnectingHandler = jest.fn();\n      wsManager.on('stateChange', ({ newState }) => {\n        if (newState === WS_STATES.RECONNECTING) {\n          reconnectingHandler();\n        }\n      });\n      \n      wsManager.disconnect();\n      \n      // Wait a bit to ensure no reconnection attempt\n      await new Promise(resolve => setTimeout(resolve, 200));\n      \n      expect(reconnectingHandler).not.toHaveBeenCalled();\n    });\n    \n    test('should stop reconnecting after max attempts', (done) => {\n      let reconnectAttempts = 0;\n      \n      wsManager.on('stateChange', ({ newState }) => {\n        if (newState === WS_STATES.RECONNECTING) {\n          reconnectAttempts++;\n        } else if (newState === WS_STATES.CLOSED) {\n          expect(reconnectAttempts).toBe(3); // maxReconnectAttempts\n          done();\n        }\n      });\n      \n      // Override WebSocket to always fail\n      global.WebSocket = class extends MockWebSocket {\n        constructor(url, protocols) {\n          super(url, protocols);\n          setTimeout(() => {\n            this.simulateError(new Error('Connection failed'));\n          }, 5);\n        }\n      };\n      \n      wsManager.connect().catch(() => {\n        // Initial connection will fail, triggering reconnection attempts\n      });\n    });\n  });\n  \n  describe('Metrics and Monitoring', () => {\n    beforeEach(async () => {\n      await wsManager.connect();\n    });\n    \n    test('should track message metrics', () => {\n      wsManager.send({ type: 'test' });\n      wsManager.ws.simulateMessage({ type: 'response' });\n      \n      const metrics = wsManager.getMetrics();\n      \n      expect(metrics.messagesSent).toBe(1);\n      expect(metrics.messagesReceived).toBe(1);\n    });\n    \n    test('should track connection uptime', () => {\n      const metrics = wsManager.getMetrics();\n      \n      expect(metrics.uptime).toBeGreaterThan(0);\n      expect(metrics.lastConnected).toBeTruthy();\n    });\n    \n    test('should track errors', () => {\n      wsManager.handleError(new Error('Test error'));\n      \n      const metrics = wsManager.getMetrics();\n      \n      expect(metrics.errors).toHaveLength(1);\n      expect(metrics.errors[0].error).toBe('Test error');\n    });\n  });\n  \n  describe('Event System', () => {\n    test('should add and remove event listeners', () => {\n      const handler = jest.fn();\n      \n      wsManager.on('test', handler);\n      wsManager.emit('test', { data: 'test' });\n      \n      expect(handler).toHaveBeenCalledWith({ data: 'test' });\n      \n      wsManager.off('test', handler);\n      wsManager.emit('test', { data: 'test2' });\n      \n      expect(handler).toHaveBeenCalledTimes(1);\n    });\n    \n    test('should handle multiple listeners for same event', () => {\n      const handler1 = jest.fn();\n      const handler2 = jest.fn();\n      \n      wsManager.on('test', handler1);\n      wsManager.on('test', handler2);\n      wsManager.emit('test', { data: 'test' });\n      \n      expect(handler1).toHaveBeenCalled();\n      expect(handler2).toHaveBeenCalled();\n    });\n    \n    test('should handle errors in event handlers gracefully', () => {\n      const errorHandler = jest.fn(() => {\n        throw new Error('Handler error');\n      });\n      const normalHandler = jest.fn();\n      \n      wsManager.on('test', errorHandler);\n      wsManager.on('test', normalHandler);\n      \n      // Should not throw\n      expect(() => {\n        wsManager.emit('test', { data: 'test' });\n      }).not.toThrow();\n      \n      expect(normalHandler).toHaveBeenCalled();\n    });\n  });\n  \n  describe('Cleanup and Destruction', () => {\n    test('should clean up resources on destroy', async () => {\n      await wsManager.connect();\n      \n      wsManager.subscribe('test.channel');\n      wsManager.on('test', jest.fn());\n      \n      wsManager.destroy();\n      \n      expect(wsManager.getState()).toBe(WS_STATES.DISCONNECTED);\n      expect(wsManager.eventHandlers.size).toBe(0);\n      expect(wsManager.subscriptions.size).toBe(0);\n      expect(wsManager.messageQueue).toHaveLength(0);\n    });\n  });\n});\n"