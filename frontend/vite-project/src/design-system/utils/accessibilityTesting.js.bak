/**
 * Accessibility testing and validation utilities
 * Provides tools for automated accessibility testing and validation
 */

import { getContrastRatio, meetsContrastRequirement } from './accessibility';

/**
 * Axe-core integration for automated accessibility testing
 */
export const axeTestingUtils = {
    // Run axe tests on a container element
    runAxeTests: async (container, options = {}) => {
        try {
            // Dynamic import of axe-core to avoid bundling issues
            // Check if axe-core is available
            let axe;
            try {
                axe = await import('axe-core');
            } catch (importError) {
                console.warn('axe-core not available, skipping axe tests');
                return {
                    error: 'axe-core not installed',
                    violations: [],
                    passes: [],
                    incomplete: [],
                    inaccessible: [],
                    summary: { violationCount: 0, passCount: 0, incompleteCount: 0, score: 100 }
                };
            }

            const defaultOptions = {
                rules: {
                    // Enable all rules by default
                    'color-contrast': { enabled: true },
                    'keyboard-navigation': { enabled: true },
                    'focus-management': { enabled: true },
                    'aria-labels': { enabled: true },
                    'semantic-markup': { enabled: true }
                },
                tags: ['wcag2a', 'wcag2aa', 'wcag21aa'],
                ...options
            };

            const results = await axe.default.run(container, defaultOptions);
            return {
                violations: results.violations,
                passes: results.passes,
                incomplete: results.incomplete,
                inaccessible: results.inaccessible,
                summary: {
                    violationCount: results.violations.length,
                    passCount: results.passes.length,
                    incompleteCount: results.incomplete.length,
                    score: calculateAccessibilityScore(results)
                }
            };
        } catch (error) {
            console.error('Axe testing failed:', error);
            return {
                error: error.message,
                violations: [],
                passes: [],
                incomplete: [],
                inaccessible: []
            };
        }
    },

    // Generate accessibility report
    generateReport: (results) => {
        const { violations, passes, incomplete, summary } = results;

        return {
            timestamp: new Date().toISOString(),
            score: summary.score,
            summary: {
                total: summary.violationCount + summary.passCount + summary.incompleteCount,
                violations: summary.violationCount,
                passes: summary.passCount,
                incomplete: summary.incompleteCount
            },
            violations: violations.map(violation => ({
                id: violation.id,
                impact: violation.impact,
                description: violation.description,
                help: violation.help,
                helpUrl: violation.helpUrl,
                nodes: violation.nodes.length,
                tags: violation.tags
            })),
            recommendations: generateRecommendations(violations)
        };
    }
};

/**
 * Color contrast validation tools
 */
export const contrastValidation = {
    // Check contrast ratio for all text elements
    validatePageContrast: (container = document.body) => {
        const textElements = container.querySelectorAll('*');
        const results = [];

        textElements.forEach(element => {
            const styles = window.getComputedStyle(element);
            const textColor = styles.color;
            const backgroundColor = getEffectiveBackgroundColor(element);

            if (textColor && backgroundColor && hasTextContent(element)) {
                const ratio = getContrastRatio(textColor, backgroundColor);
                const fontSize = parseFloat(styles.fontSize);
                const fontWeight = styles.fontWeight;
                const isLargeText = fontSize >= 18 || (fontSize >= 14 && (fontWeight === 'bold' || parseInt(fontWeight) >= 700));

                results.push({
                    element,
                    textColor,
                    backgroundColor,
                    ratio,
                    isLargeText,
                    meetsAA: meetsContrastRequirement(textColor, backgroundColor, 'AA', isLargeText ? 'large' : 'normal'),
                    meetsAAA: meetsContrastRequirement(textColor, backgroundColor, 'AAA', isLargeText ? 'large' : 'normal'),
                    selector: getElementSelector(element)
                });
            }
        });

        return {
            results,
            summary: {
                total: results.length,
                passing: results.filter(r => r.meetsAA).length,
                failing: results.filter(r => !r.meetsAA).length,
                passingAAA: results.filter(r => r.meetsAAA).length
            }
        };
    },

    // Validate specific color combination
    validateColorCombination: (foreground, background, options = {}) => {
        const { level = 'AA', size = 'normal' } = options;
        const ratio = getContrastRatio(foreground, background);
        const meets = meetsContrastRequirement(foreground, background, level, size);

        return {
            foreground,
            background,
            ratio: Math.round(ratio * 100) / 100,
            meets,
            level,
            size,
            required: level === 'AAA' ? (size === 'large' ? 4.5 : 7) : (size === 'large' ? 3 : 4.5),
            recommendation: meets ? 'Passes' : generateContrastRecommendation(ratio, level, size)
        };
    },

    // Generate accessible color palette
    generateAccessibleColors: (baseColor, backgroundColor = '#ffffff') => {
        const shades = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900];
        const palette = {};

        shades.forEach(shade => {
            const color = adjustColorForShade(baseColor, shade);
            const validation = contrastValidation.validateColorCombination(color, backgroundColor);

            palette[shade] = {
                color,
                ...validation,
                usage: getColorUsageRecommendation(validation)
            };
        });

        return palette;
    }
};

/**
 * Keyboard navigation testing utilities
 */
export const keyboardTesting = {
    // Test tab order and keyboard navigation
    testTabOrder: (container) => {
        const focusableElements = getFocusableElements(container);
        const results = [];

        focusableElements.forEach((element, index) => {
            const tabIndex = element.tabIndex;
            const hasVisibleFocus = hasVisibleFocusIndicator(element);
            const isKeyboardAccessible = isElementKeyboardAccessible(element);

            results.push({
                element,
                index,
                tabIndex,
                hasVisibleFocus,
                isKeyboardAccessible,
                selector: getElementSelector(element),
                issues: getKeyboardAccessibilityIssues(element)
            });
        });

        return {
            results,
            summary: {
                total: results.length,
                accessible: results.filter(r => r.isKeyboardAccessible).length,
                withVisibleFocus: results.filter(r => r.hasVisibleFocus).length,
                issues: results.reduce((acc, r) => acc + r.issues.length, 0)
            }
        };
    },

    // Test keyboard shortcuts
    testKeyboardShortcuts: (shortcuts, container = document.body) => {
        const results = [];

        Object.entries(shortcuts).forEach(([key, handler]) => {
            const testResult = {
                key,
                handler: typeof handler === 'function',
                conflicts: findKeyboardConflicts(key, container),
                documented: isShortcutDocumented(key)
            };

            results.push(testResult);
        });

        return {
            results,
            summary: {
                total: results.length,
                working: results.filter(r => r.handler).length,
                conflicts: results.filter(r => r.conflicts.length > 0).length,
                documented: results.filter(r => r.documented).length
            }
        };
    },

    // Test focus trap functionality
    testFocusTrap: (container) => {
        const focusableElements = getFocusableElements(container);

        if (focusableElements.length === 0) {
            return {
                working: false,
                issue: 'No focusable elements found in container'
            };
        }

        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];

        return {
            working: true,
            firstElement: getElementSelector(firstElement),
            lastElement: getElementSelector(lastElement),
            elementCount: focusableElements.length,
            canTrapFocus: true // In real implementation, would test actual focus trapping
        };
    }
};

/**
 * ARIA validation utilities
 */
export const ariaValidation = {
    // Validate ARIA attributes on elements
    validateAriaAttributes: (container = document.body) => {
        const elementsWithAria = container.querySelectorAll('[aria-*], [role]');
        const results = [];

        elementsWithAria.forEach(element => {
            const ariaAttributes = getAriaAttributes(element);
            const role = element.getAttribute('role');
            const validation = validateElementAria(element, ariaAttributes, role);

            results.push({
                element,
                selector: getElementSelector(element),
                role,
                attributes: ariaAttributes,
                ...validation
            });
        });

        return {
            results,
            summary: {
                total: results.length,
                valid: results.filter(r => r.isValid).length,
                invalid: results.filter(r => !r.isValid).length,
                warnings: results.reduce((acc, r) => acc + r.warnings.length, 0)
            }
        };
    },

    // Check for missing ARIA labels
    findMissingLabels: (container = document.body) => {
        const interactiveElements = container.querySelectorAll(
            'button, input, select, textarea, [role="button"], [role="link"], [role="menuitem"]'
        );

        const results = [];

        interactiveElements.forEach(element => {
            const hasLabel = hasAccessibleLabel(element);
            const labelSources = getAccessibleLabelSources(element);

            if (!hasLabel) {
                results.push({
                    element,
                    selector: getElementSelector(element),
                    tagName: element.tagName.toLowerCase(),
                    role: element.getAttribute('role'),
                    labelSources,
                    recommendations: getLabelRecommendations(element)
                });
            }
        });

        return {
            results,
            summary: {
                total: interactiveElements.length,
                missing: results.length,
                percentage: Math.round((results.length / interactiveElements.length) * 100)
            }
        };
    }
};

/**
 * Accessibility audit utilities
 */
export const accessibilityAudit = {
    // Run comprehensive accessibility audit
    runFullAudit: async (container = document.body) => {
        const results = {
            timestamp: new Date().toISOString(),
            container: getElementSelector(container)
        };

        try {
            // Run all tests
            const [
                axeResults,
                contrastResults,
                keyboardResults,
                ariaResults
            ] = await Promise.all([
                axeTestingUtils.runAxeTests(container),
                Promise.resolve(contrastValidation.validatePageContrast(container)),
                Promise.resolve(keyboardTesting.testTabOrder(container)),
                Promise.resolve(ariaValidation.validateAriaAttributes(container))
            ]);

            results.axe = axeResults;
            results.contrast = contrastResults;
            results.keyboard = keyboardResults;
            results.aria = ariaResults;
            results.score = calculateOverallScore(results);
            results.recommendations = generateAuditRecommendations(results);

        } catch (error) {
            results.error = error.message;
            results.score = 0;
        }

        return results;
    },

    // Generate remediation report
    generateRemediationReport: (auditResults) => {
        const issues = [];

        // Collect all issues
        if (auditResults.axe?.violations) {
            issues.push(...auditResults.axe.violations.map(v => ({
                type: 'axe',
                severity: v.impact,
                description: v.description,
                help: v.help,
                helpUrl: v.helpUrl,
                count: v.nodes.length
            })));
        }

        if (auditResults.contrast?.results) {
            const failingContrast = auditResults.contrast.results.filter(r => !r.meetsAA);
            issues.push(...failingContrast.map(c => ({
                type: 'contrast',
                severity: 'moderate',
                description: `Insufficient color contrast (${c.ratio.toFixed(2)}:1)`,
                element: c.selector,
                recommendation: `Increase contrast to at least 4.5:1`
            })));
        }

        if (auditResults.aria?.results) {
            const invalidAria = auditResults.aria.results.filter(r => !r.isValid);
            issues.push(...invalidAria.map(a => ({
                type: 'aria',
                severity: 'serious',
                description: 'Invalid ARIA attributes',
                element: a.selector,
                issues: a.errors
            })));
        }

        // Sort by severity
        const severityOrder = { critical: 0, serious: 1, moderate: 2, minor: 3 };
        issues.sort((a, b) => severityOrder[a.severity] - severityOrder[b.severity]);

        return {
            timestamp: new Date().toISOString(),
            totalIssues: issues.length,
            issuesBySeverity: {
                critical: issues.filter(i => i.severity === 'critical').length,
                serious: issues.filter(i => i.severity === 'serious').length,
                moderate: issues.filter(i => i.severity === 'moderate').length,
                minor: issues.filter(i => i.severity === 'minor').length
            },
            issues,
            prioritizedActions: generatePrioritizedActions(issues)
        };
    }
};

// Helper functions
const calculateAccessibilityScore = (axeResults) => {
    const total = axeResults.violations.length + axeResults.passes.length;
    if (total === 0) return 100;
    return Math.round((axeResults.passes.length / total) * 100);
};

const generateRecommendations = (violations) => {
    return violations.map(violation => ({
        id: violation.id,
        priority: violation.impact,
        action: getRemediationAction(violation),
        effort: getEstimatedEffort(violation)
    }));
};

const getEffectiveBackgroundColor = (element) => {
    // Simplified implementation - in practice, would traverse up the DOM
    // to find the effective background color
    const styles = window.getComputedStyle(element);
    return styles.backgroundColor !== 'rgba(0, 0, 0, 0)'
        ? styles.backgroundColor
        : '#ffffff';
};

const hasTextContent = (element) => {
    return element.textContent && element.textContent.trim().length > 0;
};

const getElementSelector = (element) => {
    if (element.id) return `#${element.id}`;
    if (element.className) return `${element.tagName.toLowerCase()}.${element.className.split(' ')[0]}`;
    return element.tagName.toLowerCase();
};

const getFocusableElements = (container) => {
    const focusableSelectors = [
        'button:not([disabled])',
        'input:not([disabled])',
        'select:not([disabled])',
        'textarea:not([disabled])',
        'a[href]',
        '[tabindex]:not([tabindex="-1"])',
        '[role="button"]:not([disabled])',
        '[role="link"]:not([disabled])',
        '[role="menuitem"]:not([disabled])'
    ].join(', ');

    return Array.from(container.querySelectorAll(focusableSelectors));
};

const hasVisibleFocusIndicator = (element) => {
    // Simplified check - in practice, would test actual focus styles
    const styles = window.getComputedStyle(element, ':focus');
    return styles.outline !== 'none' || styles.boxShadow !== 'none';
};

const isElementKeyboardAccessible = (element) => {
    return !element.disabled &&
        element.tabIndex >= 0 &&
        hasVisibleFocusIndicator(element);
};

const getKeyboardAccessibilityIssues = (element) => {
    const issues = [];

    if (element.disabled) issues.push('Element is disabled');
    if (element.tabIndex < 0) issues.push('Element has negative tabindex');
    if (!hasVisibleFocusIndicator(element)) issues.push('No visible focus indicator');

    return issues;
};

const calculateOverallScore = (results) => {
    const scores = [];

    if (results.axe?.summary?.score) scores.push(results.axe.summary.score);
    if (results.contrast?.summary) {
        const contrastScore = (results.contrast.summary.passing / results.contrast.summary.total) * 100;
        scores.push(contrastScore);
    }
    if (results.keyboard?.summary) {
        const keyboardScore = (results.keyboard.summary.accessible / results.keyboard.summary.total) * 100;
        scores.push(keyboardScore);
    }

    return scores.length > 0 ? Math.round(scores.reduce((a, b) => a + b) / scores.length) : 0;
};

const generateAuditRecommendations = (results) => {
    const recommendations = [];

    if (results.score < 80) {
        recommendations.push({
            priority: 'high',
            action: 'Address critical accessibility violations',
            description: 'Focus on fixing the most severe accessibility issues first'
        });
    }

    if (results.contrast?.summary?.failing > 0) {
        recommendations.push({
            priority: 'medium',
            action: 'Improve color contrast',
            description: `${results.contrast.summary.failing} elements have insufficient color contrast`
        });
    }

    return recommendations;
};

const generatePrioritizedActions = (issues) => {
    const actions = [];
    const criticalIssues = issues.filter(i => i.severity === 'critical');
    const seriousIssues = issues.filter(i => i.severity === 'serious');

    if (criticalIssues.length > 0) {
        actions.push({
            priority: 1,
            action: 'Fix critical accessibility violations',
            count: criticalIssues.length,
            estimatedHours: criticalIssues.length * 2
        });
    }

    if (seriousIssues.length > 0) {
        actions.push({
            priority: 2,
            action: 'Address serious accessibility issues',
            count: seriousIssues.length,
            estimatedHours: seriousIssues.length * 1
        });
    }

    return actions;
};

// Additional helper functions would be implemented here...
const adjustColorForShade = (baseColor, shade) => baseColor; // Simplified
const getColorUsageRecommendation = (validation) => validation.meets ? 'Safe for text' : 'Use for decorative elements only';
const findKeyboardConflicts = (key, container) => []; // Would check for conflicts
const isShortcutDocumented = (key) => true; // Would check documentation
const getAriaAttributes = (element) => ({}); // Would extract ARIA attributes
const validateElementAria = (element, attributes, role) => ({ isValid: true, warnings: [], errors: [] });
const hasAccessibleLabel = (element) => true; // Would check for accessible labels
const getAccessibleLabelSources = (element) => []; // Would find label sources
const getLabelRecommendations = (element) => []; // Would generate recommendations
const getRemediationAction = (violation) => 'Fix accessibility issue';
const getEstimatedEffort = (violation) => 'Medium';

export default {
    axeTestingUtils,
    contrastValidation,
    keyboardTesting,
    ariaValidation,
    accessibilityAudit
};