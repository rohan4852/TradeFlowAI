# Real-Time Data Streaming\n\nComprehensive real-time data streaming system for trading applications with WebSocket connections, automatic reconnection, and optimized performance.\n\n## Overview\n\nThe real-time streaming system provides:\n\n- **WebSocket Management**: Professional-grade connection handling with automatic reconnection\n- **Data Providers**: React context providers for real-time data distribution\n- **Component Integration**: Seamless integration with chart and orderbook components\n- **Performance Optimization**: Efficient data updates and memory management\n- **Error Handling**: Robust error recovery and connection monitoring\n\n## Core Components\n\n### WebSocketManager\n\nLow-level WebSocket connection manager with enterprise-grade features:\n\n```javascript\nimport { WebSocketManager, WS_STATES, MESSAGE_TYPES } from '@/design-system';\n\nconst wsManager = new WebSocketManager({\n  url: 'wss://api.example.com/ws',\n  reconnectInterval: 5000,\n  maxReconnectAttempts: 10,\n  heartbeatInterval: 30000,\n  debug: true\n});\n\n// Connection management\nawait wsManager.connect();\nwsManager.disconnect();\n\n// Event handling\nwsManager.on('connected', () => console.log('Connected'));\nwsManager.on('priceUpdate', (data) => console.log('Price:', data));\nwsManager.on('error', (error) => console.error('Error:', error));\n\n// Subscription management\nwsManager.subscribe('price.BTC/USD', { interval: '1s' });\nwsManager.unsubscribe('price.BTC/USD');\n\n// Send messages\nwsManager.send({ type: 'ping', timestamp: Date.now() });\n```\n\n#### Features\n\n- **Automatic Reconnection**: Exponential backoff with configurable attempts\n- **Heartbeat System**: Keep-alive mechanism with server ping/pong\n- **Message Queuing**: Queue messages when disconnected, send on reconnect\n- **Subscription Management**: Track and restore subscriptions after reconnection\n- **Metrics Tracking**: Connection statistics and performance monitoring\n- **Error Recovery**: Graceful error handling with detailed error reporting\n\n#### Connection States\n\n```javascript\nWS_STATES = {\n  CONNECTING: 'CONNECTING',\n  CONNECTED: 'CONNECTED',\n  DISCONNECTED: 'DISCONNECTED',\n  RECONNECTING: 'RECONNECTING',\n  ERROR: 'ERROR',\n  CLOSED: 'CLOSED'\n}\n```\n\n#### Message Types\n\n```javascript\nMESSAGE_TYPES = {\n  SUBSCRIBE: 'subscribe',\n  UNSUBSCRIBE: 'unsubscribe',\n  HEARTBEAT: 'heartbeat',\n  PRICE_UPDATE: 'price_update',\n  ORDERBOOK_UPDATE: 'orderbook_update',\n  TRADE_UPDATE: 'trade_update',\n  TICKER_UPDATE: 'ticker_update',\n  ERROR: 'error',\n  PONG: 'pong'\n}\n```\n\n### RealTimeDataProvider\n\nReact context provider for application-wide real-time data management:\n\n```jsx\nimport { RealTimeDataProvider } from '@/design-system';\n\nfunction App() {\n  return (\n    <RealTimeDataProvider\n      wsUrl=\"wss://api.example.com/ws\"\n      autoConnect={true}\n      reconnectInterval={5000}\n      maxReconnectAttempts={10}\n      debug={false}\n    >\n      <TradingDashboard />\n    </RealTimeDataProvider>\n  );\n}\n```\n\n#### Props\n\n| Prop | Type | Default | Description |\n|------|------|---------|-------------|\n| `wsUrl` | string | `'wss://api.example.com/ws'` | WebSocket server URL |\n| `autoConnect` | boolean | `true` | Connect automatically on mount |\n| `reconnectInterval` | number | `5000` | Reconnection delay in milliseconds |\n| `maxReconnectAttempts` | number | `10` | Maximum reconnection attempts |\n| `debug` | boolean | `false` | Enable debug logging |\n\n## Hooks\n\n### useRealTimeData\n\nMain hook for accessing real-time data context:\n\n```jsx\nimport { useRealTimeData } from '@/design-system';\n\nfunction TradingComponent() {\n  const {\n    connectionState,\n    isConnected,\n    connect,\n    disconnect,\n    subscribe,\n    unsubscribe,\n    getPrice,\n    getOrderbook,\n    getTrades,\n    getTicker,\n    metrics,\n    errors,\n    clearErrors\n  } = useRealTimeData();\n\n  return (\n    <div>\n      <div>Status: {connectionState}</div>\n      <div>Connected: {isConnected ? 'Yes' : 'No'}</div>\n      <div>Messages: {metrics.messagesReceived}</div>\n      \n      <button onClick={connect}>Connect</button>\n      <button onClick={disconnect}>Disconnect</button>\n      <button onClick={() => subscribe('price.BTC/USD')}>Subscribe</button>\n    </div>\n  );\n}\n```\n\n### useSymbolData\n\nHook for accessing data for a specific trading symbol:\n\n```jsx\nimport { useSymbolData } from '@/design-system';\n\nfunction SymbolDisplay({ symbol }) {\n  const {\n    price,\n    orderbook,\n    trades,\n    ticker,\n    lastUpdated,\n    isSubscribed\n  } = useSymbolData(symbol);\n\n  return (\n    <div>\n      <h3>{symbol}</h3>\n      <div>Price: ${price?.price}</div>\n      <div>Change: {price?.change}%</div>\n      <div>Volume: {ticker?.volume}</div>\n      <div>Last Updated: {new Date(lastUpdated.price).toLocaleTimeString()}</div>\n    </div>\n  );\n}\n```\n\n### usePriceSubscription\n\nHook for automatic price subscription management:\n\n```jsx\nimport { usePriceSubscription } from '@/design-system';\n\nfunction PriceDisplay({ symbol }) {\n  const {\n    price,\n    isSubscribed,\n    subscribe,\n    unsubscribe\n  } = usePriceSubscription(symbol, true); // auto-subscribe\n\n  return (\n    <div>\n      <div>Price: ${price?.price}</div>\n      <div>Subscribed: {isSubscribed ? 'Yes' : 'No'}</div>\n      \n      <button onClick={subscribe}>Subscribe</button>\n      <button onClick={unsubscribe}>Unsubscribe</button>\n    </div>\n  );\n}\n```\n\n### useOrderbookSubscription\n\nHook for automatic orderbook subscription management:\n\n```jsx\nimport { useOrderbookSubscription } from '@/design-system';\n\nfunction OrderBookDisplay({ symbol }) {\n  const {\n    orderbook,\n    isSubscribed,\n    subscribe,\n    unsubscribe\n  } = useOrderbookSubscription(symbol, true);\n\n  return (\n    <div>\n      <div>Asks: {orderbook?.asks?.length || 0}</div>\n      <div>Bids: {orderbook?.bids?.length || 0}</div>\n      <div>Subscribed: {isSubscribed ? 'Yes' : 'No'}</div>\n    </div>\n  );\n}\n```\n\n## Component Integration\n\n### Real-Time Charts\n\nIntegrate real-time data with candlestick charts:\n\n```jsx\nimport { CandlestickChart } from '@/design-system';\n\nfunction RealTimeChart({ symbol, data }) {\n  return (\n    <CandlestickChart\n      data={data}\n      symbol={symbol}\n      realTime={true}\n      height=\"400px\"\n      onRealTimeUpdate={(update) => {\n        console.log('Price update:', update);\n      }}\n    />\n  );\n}\n```\n\n### Real-Time Order Book\n\nIntegrate real-time data with order book visualization:\n\n```jsx\nimport { OrderBook } from '@/design-system';\n\nfunction RealTimeOrderBook({ symbol, asks, bids }) {\n  return (\n    <OrderBook\n      asks={asks}\n      bids={bids}\n      symbol={symbol}\n      realTime={true}\n      height=\"600px\"\n      onRealTimeUpdate={(update) => {\n        console.log('Orderbook update:', update);\n      }}\n    />\n  );\n}\n```\n\n## Data Flow\n\n```\nWebSocket Server\n       ↓\nWebSocketManager\n       ↓\nRealTimeDataProvider\n       ↓\n   useRealTimeData\n       ↓\n  React Components\n```\n\n### Message Flow\n\n1. **Connection**: WebSocketManager establishes connection\n2. **Subscription**: Components subscribe to data channels\n3. **Data Reception**: Server sends real-time updates\n4. **Data Processing**: Provider processes and stores data\n5. **Component Updates**: React components re-render with new data\n\n### Data Structure\n\n#### Price Update\n```javascript\n{\n  type: 'price_update',\n  symbol: 'BTC/USD',\n  price: {\n    price: 50000.00,\n    change: 250.00,\n    changePercent: 0.5,\n    volume: 1000.5,\n    timestamp: 1640995200000\n  }\n}\n```\n\n#### Orderbook Update\n```javascript\n{\n  type: 'orderbook_update',\n  symbol: 'BTC/USD',\n  orderbook: {\n    asks: [\n      { price: 50100.00, size: 1.5, timestamp: 1640995200000 },\n      { price: 50150.00, size: 2.0, timestamp: 1640995200000 }\n    ],\n    bids: [\n      { price: 49900.00, size: 2.5, timestamp: 1640995200000 },\n      { price: 49850.00, size: 1.8, timestamp: 1640995200000 }\n    ]\n  }\n}\n```\n\n#### Trade Update\n```javascript\n{\n  type: 'trade_update',\n  symbol: 'BTC/USD',\n  trades: [\n    {\n      price: 50000.00,\n      size: 0.5,\n      side: 'buy',\n      timestamp: 1640995200000\n    }\n  ]\n}\n```\n\n## Performance Optimization\n\n### Memory Management\n\n- **Data Limits**: Automatic cleanup of old data (trades limited to 100 entries)\n- **Subscription Tracking**: Efficient subscription management\n- **Event Cleanup**: Proper event listener cleanup on unmount\n\n### Update Frequency\n\n- **Throttling**: Built-in update throttling for high-frequency data\n- **Batching**: Message batching for improved performance\n- **Selective Updates**: Only update components with active subscriptions\n\n### Connection Optimization\n\n- **Heartbeat**: Efficient keep-alive mechanism\n- **Reconnection**: Smart reconnection with exponential backoff\n- **Message Queuing**: Queue messages during disconnection\n\n## Error Handling\n\n### Connection Errors\n\n```jsx\nfunction ErrorDisplay() {\n  const { errors, clearErrors } = useRealTimeData();\n\n  return (\n    <div>\n      {errors.map(error => (\n        <div key={error.id} className=\"error\">\n          [{error.type}] {error.message}\n          <small>{new Date(error.timestamp).toLocaleTimeString()}</small>\n        </div>\n      ))}\n      \n      {errors.length > 0 && (\n        <button onClick={clearErrors}>Clear Errors</button>\n      )}\n    </div>\n  );\n}\n```\n\n### Error Types\n\n- **Connection Errors**: Network connectivity issues\n- **Server Errors**: Server-side error messages\n- **Parse Errors**: Invalid message format\n- **Subscription Errors**: Failed subscription attempts\n\n## Monitoring and Metrics\n\n### Connection Metrics\n\n```jsx\nfunction MetricsDisplay() {\n  const { metrics } = useRealTimeData();\n\n  return (\n    <div>\n      <div>Messages Received: {metrics.messagesReceived}</div>\n      <div>Messages Sent: {metrics.messagesSent}</div>\n      <div>Reconnections: {metrics.reconnectCount}</div>\n      <div>Uptime: {formatUptime(metrics.uptime)}</div>\n      <div>Active Subscriptions: {metrics.subscriptions}</div>\n      <div>Queued Messages: {metrics.queuedMessages}</div>\n    </div>\n  );\n}\n```\n\n### Performance Monitoring\n\n- **Message Rate**: Messages per second tracking\n- **Latency**: Round-trip time measurement\n- **Memory Usage**: Data structure size monitoring\n- **Connection Stability**: Uptime and reconnection tracking\n\n## Testing\n\n### Unit Tests\n\n```javascript\nimport { WebSocketManager } from '@/design-system';\n\ndescribe('WebSocketManager', () => {\n  test('should connect successfully', async () => {\n    const wsManager = new WebSocketManager({ url: 'wss://test.com' });\n    await wsManager.connect();\n    expect(wsManager.isConnected()).toBe(true);\n  });\n\n  test('should handle price updates', () => {\n    const wsManager = new WebSocketManager();\n    const handler = jest.fn();\n    \n    wsManager.on('priceUpdate', handler);\n    wsManager.handleMessage({\n      data: JSON.stringify({\n        type: 'price_update',\n        symbol: 'BTC/USD',\n        price: { price: 50000 }\n      })\n    });\n    \n    expect(handler).toHaveBeenCalled();\n  });\n});\n```\n\n### Integration Tests\n\n```jsx\nimport { render, screen } from '@testing-library/react';\nimport { RealTimeDataProvider, useRealTimeData } from '@/design-system';\n\nfunction TestComponent() {\n  const { connectionState } = useRealTimeData();\n  return <div>{connectionState}</div>;\n}\n\ntest('should provide real-time data context', () => {\n  render(\n    <RealTimeDataProvider>\n      <TestComponent />\n    </RealTimeDataProvider>\n  );\n  \n  expect(screen.getByText('DISCONNECTED')).toBeInTheDocument();\n});\n```\n\n## Best Practices\n\n### Connection Management\n\n1. **Auto-Connect**: Use `autoConnect={true}` for production applications\n2. **Graceful Shutdown**: Always call `disconnect()` on component unmount\n3. **Error Handling**: Implement comprehensive error handling and user feedback\n4. **Reconnection**: Configure appropriate reconnection settings for your use case\n\n### Data Management\n\n1. **Subscription Cleanup**: Unsubscribe from unused channels to reduce bandwidth\n2. **Data Limits**: Implement data limits to prevent memory leaks\n3. **Selective Updates**: Only subscribe to data that's actively displayed\n4. **Batching**: Use batching for high-frequency updates\n\n### Performance\n\n1. **Throttling**: Implement update throttling for smooth UI performance\n2. **Memoization**: Use React.memo and useMemo for expensive calculations\n3. **Virtual Scrolling**: Use virtual scrolling for large datasets\n4. **Lazy Loading**: Load data on demand when possible\n\n### Security\n\n1. **Authentication**: Implement proper WebSocket authentication\n2. **Rate Limiting**: Respect server rate limits\n3. **Data Validation**: Validate incoming data before processing\n4. **Error Sanitization**: Sanitize error messages before displaying\n\n## Troubleshooting\n\n### Common Issues\n\n#### Connection Fails\n- Check WebSocket URL and network connectivity\n- Verify server is running and accepting connections\n- Check for firewall or proxy issues\n\n#### Data Not Updating\n- Verify subscription is active\n- Check connection state\n- Ensure component is properly subscribed to updates\n\n#### High Memory Usage\n- Check for data accumulation without cleanup\n- Verify old subscriptions are being unsubscribed\n- Monitor data structure sizes\n\n#### Poor Performance\n- Reduce update frequency for large datasets\n- Implement data throttling\n- Use React.memo for expensive components\n\n### Debug Mode\n\nEnable debug mode for detailed logging:\n\n```jsx\n<RealTimeDataProvider debug={true}>\n  <App />\n</RealTimeDataProvider>\n```\n\nThis will log:\n- Connection events\n- Message sending/receiving\n- Subscription changes\n- Error details\n- Performance metrics\n\n## Examples\n\nSee the `RealTimeDemo` component for a comprehensive example of all real-time streaming features in action.\n"