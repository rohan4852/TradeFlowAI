import React from 'react'; \nimport { render, screen, act, waitFor } from '@testing-library/react'; \nimport userEvent from '@testing-library/user-event'; \nimport { RealTimeDataProvider, useRealTimeData, useSymbolData, usePriceSubscription } from '../RealTimeDataProvider'; \nimport { WS_STATES } from '../../utils/websocketManager'; \n\n// Mock WebSocketManager\njest.mock('../../utils/websocketManager', () => {\n  const mockWsManager = {\n    connect: jest.fn(() => Promise.resolve()),\n    disconnect: jest.fn(),\n    subscribe: jest.fn(),\n    unsubscribe: jest.fn(),\n    send: jest.fn(),\n    on: jest.fn(),\n    off: jest.fn(),\n    getMetrics: jest.fn(() => ({\n      messagesReceived: 0,\n      messagesSent: 0,\n      reconnectCount: 0,\n      uptime: 0\n    })),\n    destroy: jest.fn(),\n    getState: jest.fn(() => 'DISCONNECTED'),\n    isConnected: jest.fn(() => false)\n  };\n  \n  return {\n    WebSocketManager: jest.fn(() => mockWsManager),\n    WS_STATES: {\n      CONNECTING: 'CONNECTING',\n      CONNECTED: 'CONNECTED',\n      DISCONNECTED: 'DISCONNECTED',\n      RECONNECTING: 'RECONNECTING',\n      ERROR: 'ERROR',\n      CLOSED: 'CLOSED'\n    },\n    MESSAGE_TYPES: {\n      SUBSCRIBE: 'subscribe',\n      UNSUBSCRIBE: 'unsubscribe',\n      PRICE_UPDATE: 'price_update',\n      ORDERBOOK_UPDATE: 'orderbook_update',\n      TRADE_UPDATE: 'trade_update',\n      TICKER_UPDATE: 'ticker_update'\n    }\n  };\n});\n\n// Test component that uses the context\nconst TestComponent = () => {\n  const {\n    connectionState,\n    isConnected,\n    connect,\n    disconnect,\n    subscribe,\n    unsubscribe,\n    getPrice,\n    metrics,\n    errors\n  } = useRealTimeData();\n  \n  return (\n    <div>\n      <div data-testid=\"connection-state\">{connectionState}</div>\n      <div data-testid=\"is-connected\">{isConnected.toString()}</div>\n      <div data-testid=\"metrics\">{JSON.stringify(metrics)}</div>\n      <div data-testid=\"errors-count\">{errors.length}</div>\n      \n      <button onClick={connect} data-testid=\"connect-btn\">\n        Connect\n      </button>\n      <button onClick={disconnect} data-testid=\"disconnect-btn\">\n        Disconnect\n      </button>\n      <button onClick={() => subscribe('test.channel')} data-testid=\"subscribe-btn\">\n        Subscribe\n      </button>\n      <button onClick={() => unsubscribe('test.channel')} data-testid=\"unsubscribe-btn\">\n        Unsubscribe\n      </button>\n      \n      <div data-testid=\"price-data\">\n        {JSON.stringify(getPrice('BTC/USD'))}\n      </div>\n    </div>\n  );\n};\n\n// Test component for symbol data hook\nconst SymbolDataTestComponent = ({ symbol }) => {\n  const symbolData = useSymbolData(symbol);\n  \n  return (\n    <div>\n      <div data-testid=\"symbol\">{symbolData.symbol}</div>\n      <div data-testid=\"price\">{JSON.stringify(symbolData.price)}</div>\n      <div data-testid=\"orderbook\">{JSON.stringify(symbolData.orderbook)}</div>\n      <div data-testid=\"trades\">{JSON.stringify(symbolData.trades)}</div>\n      <div data-testid=\"ticker\">{JSON.stringify(symbolData.ticker)}</div>\n    </div>\n  );\n};\n\n// Test component for price subscription hook\nconst PriceSubscriptionTestComponent = ({ symbol, autoSubscribe = true }) => {\n  const { price, isSubscribed, subscribe, unsubscribe } = usePriceSubscription(symbol, autoSubscribe);\n  \n  return (\n    <div>\n      <div data-testid=\"price\">{JSON.stringify(price)}</div>\n      <div data-testid=\"is-subscribed\">{isSubscribed.toString()}</div>\n      <button onClick={subscribe} data-testid=\"subscribe-btn\">\n        Subscribe\n      </button>\n      <button onClick={unsubscribe} data-testid=\"unsubscribe-btn\">\n        Unsubscribe\n      </button>\n    </div>\n  );\n};\n\ndescribe('RealTimeDataProvider', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  describe('Provider Setup', () => {\n    test('should render children and provide context', () => {\n      render(\n        <RealTimeDataProvider>\n          <TestComponent />\n        </RealTimeDataProvider>\n      );\n      \n      expect(screen.getByTestId('connection-state')).toHaveTextContent('DISCONNECTED');\n      expect(screen.getByTestId('is-connected')).toHaveTextContent('false');\n    });\n    \n    test('should throw error when used outside provider', () => {\n      // Suppress console.error for this test\n      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});\n      \n      expect(() => {\n        render(<TestComponent />);\n      }).toThrow('useRealTimeData must be used within a RealTimeDataProvider');\n      \n      consoleSpy.mockRestore();\n    });\n    \n    test('should initialize with custom options', () => {\n      const { WebSocketManager } = require('../../utils/websocketManager');\n      \n      render(\n        <RealTimeDataProvider\n          wsUrl=\"wss://custom.example.com/ws\"\n          autoConnect={false}\n          reconnectInterval={10000}\n          maxReconnectAttempts={5}\n          debug={true}\n        >\n          <TestComponent />\n        </RealTimeDataProvider>\n      );\n      \n      expect(WebSocketManager).toHaveBeenCalledWith({\n        url: 'wss://custom.example.com/ws',\n        reconnectInterval: 10000,\n        maxReconnectAttempts: 5,\n        debug: true\n      });\n    });\n  });\n  \n  describe('Connection Management', () => {\n    test('should handle connect action', async () => {\n      const { WebSocketManager } = require('../../utils/websocketManager');\n      const mockWsManager = WebSocketManager();\n      \n      render(\n        <RealTimeDataProvider>\n          <TestComponent />\n        </RealTimeDataProvider>\n      );\n      \n      const connectBtn = screen.getByTestId('connect-btn');\n      \n      await act(async () => {\n        await userEvent.click(connectBtn);\n      });\n      \n      expect(mockWsManager.connect).toHaveBeenCalled();\n    });\n    \n    test('should handle disconnect action', () => {\n      const { WebSocketManager } = require('../../utils/websocketManager');\n      const mockWsManager = WebSocketManager();\n      \n      render(\n        <RealTimeDataProvider>\n          <TestComponent />\n        </RealTimeDataProvider>\n      );\n      \n      const disconnectBtn = screen.getByTestId('disconnect-btn');\n      \n      act(() => {\n        userEvent.click(disconnectBtn);\n      });\n      \n      expect(mockWsManager.disconnect).toHaveBeenCalled();\n    });\n    \n    test('should handle connection state changes', () => {\n      const { WebSocketManager } = require('../../utils/websocketManager');\n      const mockWsManager = WebSocketManager();\n      \n      render(\n        <RealTimeDataProvider>\n          <TestComponent />\n        </RealTimeDataProvider>\n      );\n      \n      // Simulate state change event\n      const stateChangeHandler = mockWsManager.on.mock.calls.find(\n        call => call[0] === 'stateChange'\n      )[1];\n      \n      act(() => {\n        stateChangeHandler({ newState: WS_STATES.CONNECTED });\n      });\n      \n      expect(screen.getByTestId('connection-state')).toHaveTextContent('CONNECTED');\n    });\n  });\n  \n  describe('Subscription Management', () => {\n    test('should handle subscribe action', () => {\n      const { WebSocketManager } = require('../../utils/websocketManager');\n      const mockWsManager = WebSocketManager();\n      \n      render(\n        <RealTimeDataProvider>\n          <TestComponent />\n        </RealTimeDataProvider>\n      );\n      \n      const subscribeBtn = screen.getByTestId('subscribe-btn');\n      \n      act(() => {\n        userEvent.click(subscribeBtn);\n      });\n      \n      expect(mockWsManager.subscribe).toHaveBeenCalledWith('test.channel', {});\n    });\n    \n    test('should handle unsubscribe action', () => {\n      const { WebSocketManager } = require('../../utils/websocketManager');\n      const mockWsManager = WebSocketManager();\n      \n      render(\n        <RealTimeDataProvider>\n          <TestComponent />\n        </RealTimeDataProvider>\n      );\n      \n      const unsubscribeBtn = screen.getByTestId('unsubscribe-btn');\n      \n      act(() => {\n        userEvent.click(unsubscribeBtn);\n      });\n      \n      expect(mockWsManager.unsubscribe).toHaveBeenCalledWith('test.channel');\n    });\n  });\n  \n  describe('Data Updates', () => {\n    test('should handle price updates', () => {\n      const { WebSocketManager } = require('../../utils/websocketManager');\n      const mockWsManager = WebSocketManager();\n      \n      render(\n        <RealTimeDataProvider>\n          <TestComponent />\n        </RealTimeDataProvider>\n      );\n      \n      // Find the price update handler\n      const priceUpdateHandler = mockWsManager.on.mock.calls.find(\n        call => call[0] === 'priceUpdate'\n      )[1];\n      \n      const priceUpdate = {\n        symbol: 'BTC/USD',\n        price: { price: 50000, change: 100 }\n      };\n      \n      act(() => {\n        priceUpdateHandler(priceUpdate);\n      });\n      \n      const priceData = screen.getByTestId('price-data');\n      expect(priceData).toHaveTextContent('50000');\n    });\n    \n    test('should handle orderbook updates', () => {\n      const { WebSocketManager } = require('../../utils/websocketManager');\n      const mockWsManager = WebSocketManager();\n      \n      render(\n        <RealTimeDataProvider>\n          <SymbolDataTestComponent symbol=\"BTC/USD\" />\n        </RealTimeDataProvider>\n      );\n      \n      // Find the orderbook update handler\n      const orderbookUpdateHandler = mockWsManager.on.mock.calls.find(\n        call => call[0] === 'orderbookUpdate'\n      )[1];\n      \n      const orderbookUpdate = {\n        symbol: 'BTC/USD',\n        orderbook: {\n          asks: [{ price: 50100, size: 1.5 }],\n          bids: [{ price: 49900, size: 2.0 }]\n        }\n      };\n      \n      act(() => {\n        orderbookUpdateHandler(orderbookUpdate);\n      });\n      \n      const orderbookData = screen.getByTestId('orderbook');\n      expect(orderbookData).toHaveTextContent('50100');\n    });\n    \n    test('should handle trade updates', () => {\n      const { WebSocketManager } = require('../../utils/websocketManager');\n      const mockWsManager = WebSocketManager();\n      \n      render(\n        <RealTimeDataProvider>\n          <SymbolDataTestComponent symbol=\"BTC/USD\" />\n        </RealTimeDataProvider>\n      );\n      \n      // Find the trade update handler\n      const tradeUpdateHandler = mockWsManager.on.mock.calls.find(\n        call => call[0] === 'tradeUpdate'\n      )[1];\n      \n      const tradeUpdate = {\n        symbol: 'BTC/USD',\n        trades: [\n          { price: 50000, size: 0.5, timestamp: Date.now() }\n        ]\n      };\n      \n      act(() => {\n        tradeUpdateHandler(tradeUpdate);\n      });\n      \n      const tradesData = screen.getByTestId('trades');\n      expect(tradesData).toHaveTextContent('50000');\n    });\n    \n    test('should handle ticker updates', () => {\n      const { WebSocketManager } = require('../../utils/websocketManager');\n      const mockWsManager = WebSocketManager();\n      \n      render(\n        <RealTimeDataProvider>\n          <SymbolDataTestComponent symbol=\"BTC/USD\" />\n        </RealTimeDataProvider>\n      );\n      \n      // Find the ticker update handler\n      const tickerUpdateHandler = mockWsManager.on.mock.calls.find(\n        call => call[0] === 'tickerUpdate'\n      )[1];\n      \n      const tickerUpdate = {\n        symbol: 'BTC/USD',\n        ticker: {\n          price: 50000,\n          volume: 1000,\n          high: 51000,\n          low: 49000\n        }\n      };\n      \n      act(() => {\n        tickerUpdateHandler(tickerUpdate);\n      });\n      \n      const tickerData = screen.getByTestId('ticker');\n      expect(tickerData).toHaveTextContent('50000');\n    });\n  });\n  \n  describe('Error Handling', () => {\n    test('should handle connection errors', () => {\n      const { WebSocketManager } = require('../../utils/websocketManager');\n      const mockWsManager = WebSocketManager();\n      \n      render(\n        <RealTimeDataProvider>\n          <TestComponent />\n        </RealTimeDataProvider>\n      );\n      \n      // Find the error handler\n      const errorHandler = mockWsManager.on.mock.calls.find(\n        call => call[0] === 'error'\n      )[1];\n      \n      act(() => {\n        errorHandler({ message: 'Connection failed' });\n      });\n      \n      expect(screen.getByTestId('errors-count')).toHaveTextContent('1');\n    });\n    \n    test('should handle server errors', () => {\n      const { WebSocketManager } = require('../../utils/websocketManager');\n      const mockWsManager = WebSocketManager();\n      \n      render(\n        <RealTimeDataProvider>\n          <TestComponent />\n        </RealTimeDataProvider>\n      );\n      \n      // Find the server error handler\n      const serverErrorHandler = mockWsManager.on.mock.calls.find(\n        call => call[0] === 'serverError'\n      )[1];\n      \n      act(() => {\n        serverErrorHandler({ message: 'Server error' });\n      });\n      \n      expect(screen.getByTestId('errors-count')).toHaveTextContent('1');\n    });\n  });\n  \n  describe('Metrics Tracking', () => {\n    test('should update metrics periodically', async () => {\n      const { WebSocketManager } = require('../../utils/websocketManager');\n      const mockWsManager = WebSocketManager();\n      \n      mockWsManager.getMetrics.mockReturnValue({\n        messagesReceived: 10,\n        messagesSent: 5,\n        reconnectCount: 1,\n        uptime: 30000\n      });\n      \n      render(\n        <RealTimeDataProvider>\n          <TestComponent />\n        </RealTimeDataProvider>\n      );\n      \n      // Wait for metrics to be updated\n      await waitFor(() => {\n        const metricsElement = screen.getByTestId('metrics');\n        expect(metricsElement).toHaveTextContent('10');\n      }, { timeout: 2000 });\n    });\n  });\n});\n\ndescribe('useSymbolData Hook', () => {\n  test('should return symbol data', () => {\n    render(\n      <RealTimeDataProvider>\n        <SymbolDataTestComponent symbol=\"BTC/USD\" />\n      </RealTimeDataProvider>\n    );\n    \n    expect(screen.getByTestId('symbol')).toHaveTextContent('BTC/USD');\n    expect(screen.getByTestId('price')).toHaveTextContent('undefined');\n    expect(screen.getByTestId('orderbook')).toHaveTextContent('undefined');\n    expect(screen.getByTestId('trades')).toHaveTextContent('[]');\n    expect(screen.getByTestId('ticker')).toHaveTextContent('undefined');\n  });\n});\n\ndescribe('usePriceSubscription Hook', () => {\n  test('should handle price subscription', () => {\n    const { WebSocketManager } = require('../../utils/websocketManager');\n    const mockWsManager = WebSocketManager();\n    mockWsManager.isConnected.mockReturnValue(true);\n    \n    render(\n      <RealTimeDataProvider>\n        <PriceSubscriptionTestComponent symbol=\"BTC/USD\" />\n      </RealTimeDataProvider>\n    );\n    \n    expect(screen.getByTestId('is-subscribed')).toHaveTextContent('false');\n    \n    // Simulate connection\n    const stateChangeHandler = mockWsManager.on.mock.calls.find(\n      call => call[0] === 'stateChange'\n    )[1];\n    \n    act(() => {\n      stateChangeHandler({ newState: WS_STATES.CONNECTED });\n    });\n    \n    // Should auto-subscribe when connected\n    expect(mockWsManager.subscribe).toHaveBeenCalledWith('price.BTC/USD');\n  });\n  \n  test('should handle manual subscription', () => {\n    const { WebSocketManager } = require('../../utils/websocketManager');\n    const mockWsManager = WebSocketManager();\n    mockWsManager.isConnected.mockReturnValue(true);\n    \n    render(\n      <RealTimeDataProvider>\n        <PriceSubscriptionTestComponent symbol=\"BTC/USD\" autoSubscribe={false} />\n      </RealTimeDataProvider>\n    );\n    \n    const subscribeBtn = screen.getByTestId('subscribe-btn');\n    \n    act(() => {\n      userEvent.click(subscribeBtn);\n    });\n    \n    expect(mockWsManager.subscribe).toHaveBeenCalledWith('price.BTC/USD');\n  });\n  \n  test('should handle unsubscription', () => {\n    const { WebSocketManager } = require('../../utils/websocketManager');\n    const mockWsManager = WebSocketManager();\n    \n    render(\n      <RealTimeDataProvider>\n        <PriceSubscriptionTestComponent symbol=\"BTC/USD\" />\n      </RealTimeDataProvider>\n    );\n    \n    const unsubscribeBtn = screen.getByTestId('unsubscribe-btn');\n    \n    act(() => {\n      userEvent.click(unsubscribeBtn);\n    });\n    \n    expect(mockWsManager.unsubscribe).toHaveBeenCalledWith('price.BTC/USD');\n  });\n});\n"